{
    "collab_server" : "",
    "contents" : "---\ntitle: \"R Notebook\"\noutput: html_notebook\n---\n\n```{r}\n\nrm(list = ls())\n\nsuppressMessages(library(data.table))\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(lubridate))\nsuppressMessages(library(stringr))\n\n```\n\n## Get data into R\n\n```{r}\n\norders_orig <- data.frame(fread(\"data/orders.csv\", header = T))\norder_items <- data.frame(fread(\"data/order-items.csv\", header = T))\n\n```\n\n## Create separate data frames for orders, customers, items\n\n```{r}\n\ncustomers <- orders_orig %>%\n  select(customers_id, customers_gender, customers_dob) %>%\n  unique() %>%\n  mutate(customers_id = as.numeric(customers_id)) %>%\n  arrange(customers_id)\n\norders <- orders_orig %>%\n  select(-c(customers_gender, customers_dob)) %>%\n  unique() %>%\n  mutate(customers_id = as.numeric(customers_id)) %>%\n  arrange(customers_id)\n\n```\n\n## Clean the order items table\n\n```{r}\n\norder_items <- order_items %>%\n  mutate(products_price = as.numeric(products_price)) %>%\n  mutate(products_quantity = as.numeric(products_quantity)) %>%\n  filter(products_price > 0) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"case|CASE|Case\") & !str_detect(products_name, \"6 bottles\"), products_quantity * 12, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"case|CASE|Case\") & str_detect(products_name, \"6 bottles\"), products_quantity * 6, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"12 Assorted\"), products_quantity * 12, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"Assorted\"), products_quantity * 12, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"Budget White\"), products_quantity * 12, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"30 bottles\"), products_quantity * 30, products_quantity)) %>%\n  mutate(products_quantity = ifelse(str_detect(products_name, \"Voucher\"), products_quantity * 6, products_quantity))\n\n\n# TODO: \n\n# mixed cases contain 12 bottles (6 red, 6 white)\n# seems all order items with \"case\" in the name, and not a multiple of 6 (or 12?) are actually cases and should be multiplied by 12\n# assuming assorted is 12 too\n# wynklub seems to be just one bottle\n# gift vouchers are tricky ... assume the intention is to buy 6 bottles\n# remove \"as arranged by Johan\"?\n# remove wine years?\n\n# table(order_items$products_quantity)\n# order_items[order_items$products_quantity == 1 & !str_detect(order_items$products_name, \"wynklub\"),]\n# order_items[str_detect(order_items$products_name, \"Johan\"),]\n\n```\n\n## Add features to customers table\n\n```{r}\n# number of orders\n\ncustomers <- orders %>%\n  count(customers_id) %>%\n  right_join(customers)\n\ncolnames(customers)[colnames(customers) == \"n\"] <- \"order_count\"\n\n# age and age group\n\ncustomers <- customers %>%\n  mutate(customers_dob = parse_date_time(customers_dob, \"%Y-%m-%d H:%M:%S\")) %>%\n  mutate(customer_age =  as.period(interval(customers_dob, ymd(\"20170824\")))) %>%\n  mutate(customer_age_group = ifelse(customer_age >= years(60), \"old\", ifelse(customer_age >= years(35), \"mid\", \"young\"))) %>%\n  mutate(customer_age_group = as.factor(customer_age_group))\n\n# avg. per bottle\ncustomer_item_prices <- left_join(orders, order_items) %>%\n  mutate(total_paid = products_price * products_quantity) %>%\n  group_by(customers_id) %>%\n  summarise(\"order_amount\" = sum(total_paid), \"item_count\" = sum(products_quantity)) %>%\n  mutate(avg_item = order_amount / item_count)\n\ncustomers <- customer_item_prices %>%\n  select(customers_id, avg_item) %>%\n  right_join(customers)\n\n```\n\n## Simple bought products approach (i.e. user-based collaborative filtering)\n\n```{r}\n\n# get matrix of \"bought wines\" i.e. customer_id as rows and wines as columns\n\ncustomer_products_bought_tall <- order_items %>%\n  select(orders_id, products_name) %>%\n  inner_join(orders %>% select(customers_id, orders_id)) %>% # use inner join to avoid customers without purchases?\n  select(customers_id, products_name) %>%\n  unique() %>%\n  mutate(bought = 1)\n\ncustomer_products_bought_wide <- customer_products_bought_tall %>%\n  complete(customers_id, products_name, fill = list(bought = 0)) %>%\n  spread(key = products_name, value = bought)\n\n# convert data to matrix form \nsorted_customers_id <- as.character(unlist(customer_products_bought_wide[,1]))\ncustomer_products_bought_wide <- as.matrix(customer_products_bought_wide[,-1])\nrow.names(customer_products_bought_wide) <- sorted_customers_id\n```\n\n```{r, eval=F}\n\ncosine_sim <- function(a,b){crossprod(a,b)/sqrt(crossprod(a)*crossprod(b))}\ntemp_func <- Vectorize(function(x, y) cosine_sim(customer_products_bought_wide[x,], customer_products_bought_wide[y,]))\n\ncustomer_similarities1 <- outer(seq_len(nrow(customer_products_bought_wide)),\n      seq_len(nrow(customer_products_bought_wide)),\n      temp_func)\n\ndiag(customer_similarities1) <- 0\nrow.names(customer_similarities1) <- row.names(customer_products_bought_wide)\ncolnames(customer_similarities1) <- row.names(customer_products_bought_wide)\n\nsaveRDS(customer_similarities1, \"output/customer_similarities1.rds\")\n\n# max(customer_products_bought_wide[263,])\n# cosine_sim(customer_products_bought_wide[3,], customer_products_bought_wide[3,])\n\n```\n```{r}\ncustomer_similarities1 <- readRDS(\"output/customer_similarities1.rds\")\n\n\n# sort(apply(customer_products_bought_wide, 1, sum), decreasing = T)\n# # Raka Spliced 2014\n# # Le Bonheur Prima 2013 unlabelled\n# # Knorhoek Shiraz/Cabernet Franc/Cabernet Sauvignon 2015\n# \n# crossprod(customer_products_bought_wide[, \"Raka Spliced 2014\"], customer_similarities1[\"39263\",])\n# \n# temp <- customer_similarities1[\"39263\",] %*% customer_products_bought_wide\n# # customer_similarities1[\"39263\",] %*% customer_products_bought_wide\n# dim(customer_similarities1[\"39263\",])\ndim(customer_products_bought_wide)\n# dim(temp)\n\ndim(customer_products_bought_wide[0,])\n\ncustomer_scores <- data.frame(product = colnames(customer_products_bought_wide),\n                              score = as.vector(customer_similarities1[\"39263\",] %*% customer_products_bought_wide),\n                              bought = customer_products_bought_wide[\"39263\",])\n\ncustomer_scores %>%\n  # filter(bought == 0) %>%\n  arrange(desc(score)) %>%\n  select(product, score, bought)\n```\n\n```{r}\n\ncustomer_based_recommendations <- function(customer, customer_similarities, bought_wines){\n  \n  # turn into character if not already\n  customer <- ifelse(is.character(customer),customer,as.character(customer))\n  \n  # get scores\n  customer_scores <- data.frame(title = colnames(bought_wines), \n                            score = as.vector(customer_similarities[customer,] %*% bought_wines), \n                            bought = bought_wines[customer,])\n  \n  # sort unseen movies by score and remove the 'seen' column\n  customer_recom <- customer_scores %>% \n    filter(bought == 0) %>%\n    arrange(desc(score)) %>% \n    select(-bought) \n  \n  return(customer_recom)\n  \n}\n\ncustomer_based_recommendations(\"39263\", customer_similarities1, customer_products_bought_wide)\n\n```\n\n## Item-based approach\n\n```{r, eval=F}\n\nproducts_customers_wide <- t(customer_products_bought_wide)\n\ntemp_func <- Vectorize(function(x, y) cosine_sim(products_customers_wide[x,], products_customers_wide[y,]))\n\nproduct_similarities1 <- outer(seq_len(nrow(products_customers_wide)),\n      seq_len(nrow(products_customers_wide)),\n      temp_func)\n\ndiag(product_similarities1) <- 0\nrow.names(product_similarities1) <- row.names(products_customers_wide)\ncolnames(product_similarities1) <- row.names(products_customers_wide)\n\nsaveRDS(product_similarities1, \"output/product_similarities1.rds\")\n```\n```{r}\nproduct_similarities1 <- readRDS(\"output/product_similarities1.rds\")\n```\n```{r}\nuser_bought <- customer_products_bought_tall %>% \n        filter(customers_id == \"39263\") %>% \n        select(products_name) %>% \n        unlist() %>% \n        as.character()\n\nproduct_scores <- tibble(product = row.names(product_similarities1), \n                      score = apply(product_similarities1[,user_bought],1,sum),\n                      bought = products_customers_wide[,as.character(39263)])\n\nproduct_scores %>%\n  filter(bought == 0) %>%\n  arrange(desc(score))\n\n```\n```{r}\nproduct_based_recommendations <- function(customer, product_similarities, bought_products){\n  \n  # turn into character if not already\n  customer <- ifelse(is.character(customer),customer,as.character(customer))\n  \n  # get scores\n  customer_bought <- row.names(product_similarities)[bought_products[,customer] == TRUE]\n  customer_scores <- tibble(title = row.names(product_similarities), \n                        score = apply(product_similarities[,customer_bought],1,sum),\n                        bought = bought_products[,customer])\n  # sort unseen movies by score and remove the 'seen' column\n  customer_recom <- customer_scores %>% filter(bought == 0) %>% arrange(desc(score)) %>% select(-bought)\n\n  return(customer_recom)\n  \n}\n\nproduct_based_recommendations(\"39263\", product_similarities1, products_customers_wide)\n\n# head(product_based_recommendations(\"39263\", product_similarities1, products_customers_wide)) %in% head(customer_based_recommendations(\"39263\", customer_similarities1, customer_products_bought_wide))\n\n\n```\n\n## Matrix factorization\n\nProxy for wine rating? Number of bottles?\n\nSome combination of quantity and price ... i.e. something may be really good, but expensive. Something may be mediocre but cheap. Number of bottles bias towards cheap, price per bottle bias toward expensive. Some combination of the two? And probably a log of that combination in order to reduce impact of MASSIVE orders.\n\n```{r}\nproduct_ratings <- order_items %>%\n  mutate(log_order_val = log(products_quantity * products_price)) %>% # create ratings proxy\n  inner_join(orders) %>%\n  select(customers_id, products_name, log_order_val) %>%\n  group_by(customers_id, products_name) %>%\n  summarise(rating_proxy = mean(log_order_val)) %>%\n  ungroup() %>%\n  # complete(customers_id, products_name, fill = list(ratings_proxy = NA))\n  complete(customers_id, products_name) %>%\n  spread(key = products_name, value = rating_proxy)\n\n# product_ratings %>%\n#   gather(-customers_id, key = products_name, value = rating_proxy)\n\nproducts_list <- as.character(unlist(product_ratings[,1]))\nproduct_ratings <- as.matrix(product_ratings[,-1])\nrow.names(product_ratings) <- products_list\n\n```\n```{r}\nevaluate_fit_l2_bias <- function(x, observed_ratings, customer_rows, customer_cols, product_rows, product_cols, lambda){\n  \n  # x <- runif(x_num)\n    \n  # extract user and movie factors from parameter vector (note x is defined such that \n  # the first 75 elements are latent factors for users and rest are for movies)\n  customer_factors <- matrix(x[1:(customer_rows*customer_cols)],customer_rows,customer_cols)\n  product_factors <- matrix(x[(customer_rows*customer_cols + 1):(customer_rows*customer_cols + product_rows*product_cols)],product_rows,product_cols)\n  \n  #biases\n  customer_bias <- matrix(x[(customer_rows*customer_cols + product_rows*product_cols + 1):(customer_rows*customer_cols + product_rows*product_cols + 1 + customer_rows)],nrow=customer_rows,ncol=product_cols)\n  \n  # dim(customer_bias)\n  \n  product_bias <- t(matrix(x[(customer_rows*customer_cols + product_rows*product_cols + 1 + customer_rows + 1):(customer_rows*customer_cols + product_rows*product_cols + 1 + customer_rows + 1 + product_rows)],nrow=product_cols,ncol=customer_rows))\n  \n  # dim(product_bias)\n  \n  # get predictions from dot products of respective user and movie factor\n  predicted_ratings <- customer_factors %*% product_factors + customer_bias + product_bias\n  # dim(predicted_ratings)\n  \n  # model accuracy is sum of squared errors over all rated movies\n  # observed_ratings <- product_ratings\n  # dim(observed_ratings)\n  errors <- (observed_ratings - predicted_ratings)^2\n  penalty <- sum(sqrt(apply(customer_factors^2,1,sum))) + sum(sqrt(apply(product_factors^2,2,sum)))\n  # lambda <- 3e-3\n  accuracy <- sqrt(mean(errors[!is.na(observed_ratings)])) + lambda * penalty \n  \n  return(accuracy)\n}\n\ndim(product_ratings)\nfactor_depth <- 10\ncustomer_rows <- dim(product_ratings)[1]\ncustomer_cols <- factor_depth\nproduct_cols <- dim(product_ratings)[2]\nproduct_rows <- factor_depth\n\nx_num <- customer_rows*customer_cols + product_cols*product_rows + customer_rows + product_cols\n\n\nset.seed(10)\n# optimization step (note longer parameter vector to include bias)\nrec1 <- optim(par=runif(x_num),evaluate_fit_l2_bias,\n              observed_ratings = product_ratings,\n              customer_rows = customer_rows,\n              customer_cols = customer_cols,\n              product_rows = product_rows,\n              product_cols = product_cols,\n              lambda = 3e-3,\n              control=list(maxit=100),\n              method = \"BFGS\")\nrec1$convergence\nrec1$value\n\n```\n\n```{r}\nlibrary(NNLM)\n\nset.seed(7)\n\nrw_decomp <- nnmf(A = product_ratings,\n                  alpha = 3e-3,\n                  beta = 3e-3,\n                  method = \"scd\",\n                  k = 20,\n                  max.iter = 10000\n                  )\n\nW <- rw_decomp$W\nH <- rw_decomp$H\n\nobserved <- W %*% H\n\nerrors <- (observed - product_ratings)^2\naccuracy <- sqrt(mean(errors[!is.na(product_ratings)]))\n\naccuracy\nrw_decomp$n.iteration\n\n```\n\n",
    "created" : 1503579086336.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1818078723",
    "id" : "45A89535",
    "lastKnownWriteTime" : 1504003194,
    "last_content_update" : 1504013524744,
    "path" : "~/Dropbox (Personal)/MScDataScience/DS_Industry/assignment_1/data_cleaning_featureengineering.Rmd",
    "project_path" : "data_cleaning_featureengineering.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}